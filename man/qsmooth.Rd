% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AllClasses.R
\docType{methods}
\name{show}
\alias{qsmooth}
\alias{qstats}
\alias{show}
\title{qstats}
\usage{
qstats(object, groupFactor, qRange, window = 0.05)

qsmooth(object, groupFactor, batch = NULL, normFactors = NULL,
  window = 0.05)
}
\arguments{
\item{object}{an object which is inherited from an 
\code{eSet} such as an \code{ExpressionSet} or 
\code{MethylSet} object. The \code{object} can also be a 
data frame or matrix with observations
(e.g. probes or genes) on the rows and samples as the 
columns.}

\item{groupFactor}{a group level continuous or categorial 
covariate associated with each sample or column in the 
\code{object}. The order of the \code{groupFactor} must 
match the order of the columns in \code{object}.}

\item{window}{window size for running median which is 
a fraction of the number of rows in \code{object}. 
Default is 0.05.}

\item{batch}{(Optional) batch covariate (multiple batches are not allowed). 
If batch covariate is provided, \code{Combat()} from \code{sva} 
is used prior to qsmooth normalization to remove batch effects. 
See \code{Combat()} for more details.}

\item{normFactors}{optional normalization scaling factors.}

\item{object}{an object which is inherited from an 
\code{eSet} such as an \code{ExpressionSet} or 
\code{MethylSet} object. The \code{object} can also be a 
data frame or matrix with observations
(e.g. probes or genes) on the rows and samples as the 
columns.}

\item{groupFactor}{a group level continuous or categorial 
covariate associated with each sample or column in the 
\code{object}. The order of the \code{groupFactor} must 
match the order of the columns in \code{object}.}

\item{window}{window size for running median which is 
a fraction of the number of rows in \code{object}. 
Default is 0.05.}
}
\value{
A list of quantile statistics including 
\item{Q}{sample quantiles}
\item{Qref}{reference quantile}
\item{Qhat}{linear model fit at each quantile}
\item{SST}{total sum of squares}
\item{SSB}{between sum of squares}
\item{SSE}{within sum of squares}
\item{roughWeights}{SSE / SST}
\item{smoothWeights}{smoothed weights computed using a 
running median with a given \code{window} size.}

A normalized matrix of values after applying 
smoothed quantile normalization.
}
\description{
This function is a helper function that 
computes quantile statistics for the function 
\code{qsmooth}.

This function applies a generalization of 
quantile normalization called smoothed quantile 
normalization. This function defines the qsmooth class 
and constructor.
}
\details{
Quantile normalization is one of the most widely used normalization tools 
for data analysis in genomics. Although it was originally developed for 
gene expression microarrays it is now used across many different 
high-throughput applications including RNAseq and ChIPseq. The methodology 
relies on the assumption that observed changes in the empirical 
distribution of samples are due to unwanted variability. Because the data is 
transformed to remove these differences it has the potential to remove 
interesting biologically driven global variation. Therefore, applying 
quantile normalization, or other global normalization methods
that rely on similar assumptions, may not be an appropriate depending 
on the type and source of variation. 

This function computes a weight at every 
quantile that compares the variability between groups 
relative to within groups. In one extreme quantile 
normalization is applied and in the other extreme quantile 
normalization within each biological condition is applied. 
The weight shrinks the group-level quantile normalized data 
towards the overall reference quantiles if variability 
between groups is sufficiently smaller than the variability 
within groups. 
See the vignette for more details.
}
\examples{
library(Biobase)
library(bodymapRat)
data(bodymapRat)
# select lung and liver samples, stage 21 weeks, and bio reps
keepColumns = (pData(bodymapRat)$organ \%in\% c("Lung", "Liver")) & 
         (pData(bodymapRat)$stage == 21) & (pData(bodymapRat)$techRep == 1)
keepRows = rowMeans(exprs(bodymapRat)) > 10 # Filter out low counts
bodymapRat <- bodymapRat[keepRows,keepColumns]
pd <- pData(bodymapRat)

qs <- qstats(object = exprs(bodymapRat), groupFactor = pd$organ, window = 0.05)

library(Biobase)
library(bodymapRat)
data(bodymapRat)
# select lung and liver samples, stage 21 weeks, and bio reps
keepColumns = (pData(bodymapRat)$organ \%in\% c("Lung")) & 
         (pData(bodymapRat)$stage == 21) & (pData(bodymapRat)$techRep == 1)
keepRows = rowMeans(exprs(bodymapRat)) > 10 # Filter out low counts
bodymapRat <- bodymapRat[keepRows,keepColumns]
pd <- pData(bodymapRat)
pd$group <- paste(pd$sex, pd$organ, sep="_")

qsNorm <- qsmooth(object = exprs(bodymapRat), groupFactor = pd$pd$group)

}

